(ns cljd.flutter.alpha
  "Bridging Flutter and Clojure"
  (:require ["package:flutter/widgets.dart" :as widgets]
            ["package:flutter/foundation.dart" :as foundation]
            [cljd.string :as str]
            ["dart:async" :as async])
  (:host-ns
   (:require [clojure.string :as str])))

; TODO create our own Key type which uses equiv and not ==

(defprotocol ISubscribable
  (-subscribe [x opts cb]
    "Returns [cancel current-value], cancal is a 0-arg effect to unsubscribe. (cb x) will be called each time a new value is available."))

(extend-protocol ISubscribable
  async/Future
  (-subscribe [f opts cb]
    (let [cancelled (volatile! false)]
      (.then f (fn [x] (when-not @cancelled (cb x))))
      [(:or opts) #(vreset! cancelled true)]))
  async/Stream
  (-subscribe [s opts cb]
    (let [sub (.listen s cb)]
      [(:or opts) #(.cancel sub)]))
  fallback
  (-subscribe [watchable opts cb]
    (let [k (Object)]
      (add-watch watchable k (fn [k r o n] (cb n)))
      [@watchable #(remove-watch watchable k)])))

(defmacro nest
  "Nest forms (the first form being the root form, the 2nd its child, the 3rd its grand child...) adding the :child keyword before each nested form."
  [form & forms]
  (let [[form & forms] (reverse (cons form forms))]
    `(->> ~form ~@(for [form forms] (-> form (cond-> (symbol? form) list) (concat  [:child]) (with-meta (meta form)))))))

(defn- ^:macro-support camel-kebab [s]
  (str/replace s #"(^[A-Z])|[A-Z]" (fn [[s start]] (cond->> (str/lower-case s) (not start) (str "-")))))

(defmacro ^:private ^:macro-support else->> [& forms] `(->> ~@(reverse forms)))

(defn update-subscriptions [new-watchees+opts old-watchees+opts ^List vals-then-cancels ^widgets/State state]
  (let [N (quot (.-length vals-then-cancels) 2)]
    (dotimes [i N]
      (let [n (nth new-watchees+opts i)
            o (nth old-watchees+opts i)]
        (when (and o (not= n o)) ((aget vals-then-cancels (+ N i)))) ; cancel
        (when (and n (not= n o))
          (let [[w opts] n
                [v c] (-subscribe w opts (fn [v] (aset vals-then-cancels i v)
                                           (.setState state (fn []))))]
            (aset vals-then-cancels i v)
            (aset vals-then-cancels (+ N i) c)))))))

(defn- ^:macro-support roll-trailing-opts [bindings supported-opts]
  (reduce
    (fn [triples [lhs rhs]]
      (else->>
        (if-not (keyword? lhs) (conj triples [lhs rhs {}]))
        (let [supported (supported-opts lhs)
              [l r opts] (peek triples)])
        (if (nil? l) (throw (Exception. "Options must follow a binding form.")))
        (if-not supported (throw (Exception. (str "Unsupported option " lhs))))
        (if (fn? supported)
          (conj (pop triples) [l r (merge-with supported opts {lhs rhs})]))
        (if (contains? opts lhs) (throw (Exception. (str "Duplicate option " lhs))))
        (conj (pop triples) [l r (assoc opts lhs rhs)])))
    []
    (partition 2 bindings)))

(defmacro widget
  "Creates a widget by evaluating the body.
   The body may be preceded by options in the form of interleaved
   option names (as keywords) with their values.
   :key expr, when present, is used as the key of the widget, plain value,
              not a Key.

   :watch symbol-referencing an atom: this widget will be rebuilt everytime
          the atom change.
   :state [name init-value] creates an atom named state initialized to init-value,
                            watch for changes tp it.

   :context name, if you need to access the build context then provide its name here.

   :ticker name, bind name to a TickerProvider for a single AnimationController
   :tickers name, bind name to a TickerProvider for a several AnimationControllers

   :with [name-or-opt expr ...], declare resources whose lifecycle is managed
   by this widget. (They are initialized and disposed by this widget.)
   Each name-or-opt expr pair is either:
     * name init-expr: initialize resource with init-expr and bind it under
       name, by default the resource will be freed by calling .dispose on it;
     * :dispose dispose-expr (right after a name init-expr pair) which tells
       to dispose of the resource by doing (-> name dispose-expr);
     * :let bindings, to introduce intermediate values which are not
       managed resources.
   "
  {:arglists '[[:opt1 val1 ... :optN valN & body]]}
  [& args]
  (let [opts (take-while (comp keyword? first) (partition 2 args))
        body (drop (* 2 (count opts)) args)
        {:keys [context key state watch with ticker tickers bind inherit nested-in] :as opts} (into {} (map vec) opts)
        flutter-build-ctx (vary-meta (or context `ctx#) assoc :tag `widgets/BuildContext)
        _ (when (symbol? watch)
            (binding [#_#_*out* *err*]
              (println "DEPRECATED :watch expects a binding vector. Right-hand side expressions must be subscribable: atoms, futures, streams. Left-hand side will be bound to the current value.")))
        key-level (cond
                    (seq bind) :bind
                    (seq nested-in) :nested-in
                    :else :base)
        key-exprs {key-level (cond-> key (not= key-level :bind) (some->> (list `foundation/ValueKey.)))}
        ticker-mixin (cond tickers `^:mixin widgets/TickerProviderStateMixin ticker `^:mixin widgets/SingleTickerProviderStateMixin)
        inherit (if (vector? inherit) {:of inherit} inherit)
        inherit (if-some [shortcuts (:of inherit)]
                  (into (dissoc inherit :of)
                    (map (fn [type-or-kw]
                           (let [hint (cond-> type-or-kw (seq? type-or-kw) first)]
                             [(symbol
                                (if (keyword? hint)
                                  (name hint)
                                  (camel-kebab (re-find #"[^.]+$" (name hint)))))
                              type-or-kw])))
                    shortcuts)
                  inherit)
        inherits-bindings
        (mapcat
          (fn [[sym type-or-kw]]
            (let [[type-or-kw & args] (cond-> type-or-kw (not (seq? type-or-kw)) list)]
              [sym
               (if (keyword? type-or-kw)
                 `(get-state-of ~flutter-build-ctx ~type-or-kw ~(vec args))
                 (list*
                   (symbol
                     (if-some [ns (namespace type-or-kw)]
                       (str ns "." (name type-or-kw))
                       (name type-or-kw))
                     "of")
                   flutter-build-ctx args))]))
          inherit)
        watch-triples (roll-trailing-opts watch (constantly true))
        widget-resources (into [] (map second) watch-triples)
        with-triples (roll-trailing-opts with {:let into :dispose true})
        init-let-bindings
        (into []
          (mapcat (fn [[lhs rhs {bindings :let}]]
                    (into [lhs rhs] bindings)))
          with-triples)
        dispose-statements (into [] ; we lose inferred types
                             (map (fn [[lhs rhs {:keys [dispose]}]]
                                    `(-> ~lhs ~(or dispose '.dispose))))
                             (rseq with-triples))
        build+dispose `build+dispose#
        watchees-state `watchees-state#
        state-sym `^widgets/State state#
        super (vary-meta state-sym assoc :tag 'super)
        expr `(let [~@inherits-bindings] ~@body)
        user-widget
        (if (or (seq state) (seq watch-triples) (seq with-triples) ticker-mixin)
          `(let [watchees+opts# [~@(for [[_ e o] watch-triples] [e o])]] ; watchees are tied to the the widget
             (reify :extends (widgets/StatefulWidget. :key ~(:base key-exprs))
               :no-meta true
               (~'debugFillProperties [~state-sym props-builder#]
                (.debugFillProperties ~super props-builder#)
                ; commenting this out as I rework :watch
                #_(doto props-builder#
                    ~@(cond-> []
                        watch
                        (conj `(.add (foundation/MessageProperty "atom" (pr-str @~watch))))))
                nil)
               (~'createState [_#]
                (let [~build+dispose (volatile! nil)
                      ; atomic state
                      ~@(when (seq state)
                          [(first state) `(atom ~(second state))])
                      ; watchees-states is an array of current values followed by
                      ; cancel functions.
                      ~watchees-state (List/filled ~(* 2 (count watch-triples)) nil)]
                  (reify :extends widgets/State
                    :no-meta true
                    (~'initState [~state-sym]
                     (.initState ~super)
                     ; atomic state
                     ~(when (seq state)
                        `(add-watch ~(first state) ~state-sym
                           (fn [k# r# o# n#] (.setState ~state-sym (fn [])))))
                     ; watchees
                     (update-subscriptions watchees+opts# nil ~watchees-state ~state-sym)
                     ; resources
                     ~(when (or (seq with) (seq watch))
                        `(let [~@(when ticker-mixin
                                   [(vary-meta (or ticker tickers) assoc :tag ticker-mixin) state-sym])
                               ~@init-let-bindings]
                           (vreset! ~build+dispose
                             [(fn [~flutter-build-ctx]
                                (let [[~@(map first watch-triples)] ~watchees-state]
                                  ~expr))
                              (fn [] ~@dispose-statements
                                (vreset! ~build+dispose nil))])))
                     nil)
                    (~'dispose [~state-sym]
                     ; resources
                     ~(when (seq with)
                        `((second (deref ~build+dispose))))
                     ; watchees
                     (update-subscriptions nil watchees+opts# ~watchees-state ~state-sym)
                     ; atomic state
                     ~(when (seq state) `(remove-watch ~(first state) ~state-sym))
                     (.dispose ~super))
                    (~'didUpdateWidget [~state-sym old-widget#]
                     (.didUpdateWidget ~super old-widget#)
                     (update-subscriptions watchees+opts# @old-widget# ~watchees-state ~state-sym))
                    (~'build [~state-sym ~flutter-build-ctx]
                     ~(if (or (seq with) (seq watch))
                        `((first (deref ~build+dispose)) ~flutter-build-ctx)
                        ; when no :with, just build here
                        expr))
                    ~@(when ticker-mixin [ticker-mixin]))))
               ; back into the widget reify
               ~'cljd.core/IDeref
               (~'-deref [_#] watchees+opts#)))
          `(reify :extends (widgets/StatelessWidget. :key ~(:base key-exprs))
             (~'build [_# ~flutter-build-ctx] ~expr)))
        user-widget
        (if-some [[top & others] (seq nested-in)]
          `(nest
             (~@(if (seq? top) top (list top)) :key ~(key-exprs :nested-in))
             ~@others
             ~user-widget)
          user-widget)]
    (if (seq bind)
      `(let [user-widget# ~user-widget]
         (widget
           :key ~(:bind key-exprs)
           :state [bindings# ~(zipmap (keys bind)
                                (for [v (vals bind)] `(ensure-model ~v)))]
           :context pctx#
           (cljd.flutter.alpha/InheritedBindings. bindings# pctx# @bindings#
             (->> user-widget#
               ))))
      user-widget)))

(defprotocol IModel
  (-state [v args swp! trck!] "Returns a mutable view of this binding in this context.")
  (-updated? [v prev-v q])
  (-update [v f]))

(deftype AssociativeState [v path swp! trck!]
  cljd.core/IDeref
  (-deref [_]
    (trck! path)
    v)
  cljd.core/ISwap
  (-swap! [o f]
    (swp! (if (seq path) #(update-in % path f) f)))
  (-swap! [o f a]
    (swp! (if (seq path) #(update-in % path f a) #(f % a))))
  (-swap! [o f a b]
    (swp! (if (seq path) #(update-in % path f a b) #(f % a b))))
  (-swap! [o f a b xs]
    (swp! (if (seq path) #(apply update-in % path f a b xs) #(apply f % a b xs))))
  cljd.core/IReset
  (-reset! [o v']
    (swp! (if (seq path) #(assoc-in % path v') (constantly v'))))
  cljd.core/ILookup
  (-lookup [o k]
    (AssociativeState. (-lookup v k) (conj path k) swp! trck!))
  (-lookup [o k not-found]
    (AssociativeState. (-lookup v k not-found) (conj path k) swp! trck!))
  (-contains-key? [o k]
    (trck! (conj path k))
    (contains? v k)))

(deftype AssociativeModel [v]
  IModel
  (-state [model args swp! trck!]
    (AssociativeState. (get-in v args) args swp! trck!))
  (-updated? [model prev-model ks] (not= (get-in v ks) (get-in (.v ^AssociativeModel prev-model) ks)))
  (-update [_ f] (AssociativeModel. (f v))))

(defn ensure-model [x]
  (if (satisfies? IModel x) x (AssociativeModel. x)))

(deftype StaticModel [v]
  IModel
  (-state [model args swp! trck!] (trck! args) (get-in v args))
  (-updated? [model prev-model ks] (not= (get-in v ks) (get-in (.v ^StaticModel prev-model) ks))))

(defn static
  "Returns a value model (not derefable, not updatable)."
  [v]
  (StaticModel. v))

(deftype InheritedBindings [state pctx snapshot child]
  :extends (widgets/InheritedModel. :child child)
  (isSupportedAspect [this name]
    (contains? snapshot name))
  (updateShouldNotify [this prev-this]
    (not= snapshot (.-snapshot ^InheritedBindings prev-this)))
  (updateShouldNotifyDependent [this prev-this aspects]
    (let [prev-snapshot (.-snapshot ^InheritedBindings prev-this)]
      (boolean
        (some (fn [[name q]]
                (-updated? (snapshot name) (prev-snapshot name) q)) aspects)))))

(defn get-state-of [^widgets/BuildContext ctx id args]
  (loop [^widgets/BuildContext ctx' ctx]
    (if-some [elt (#/(.getElementForInheritedWidgetOfExactType InheritedBindings) ctx')]
      (let [ib ^InheritedBindings (.widget elt)]
        (if (.isSupportedAspect ib id)
          (-state (get (.snapshot ib) id) args
            #(swap! (.state ib) update id -update %)
            #(.dependOnInheritedElement ctx elt :aspect [id %]))
          (recur (.pctx ib))))
      (throw (Exception (str "No inherited state for id" id))))))
